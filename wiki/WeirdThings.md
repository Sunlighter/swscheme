I started writing this code in 2005 when C# 2.0 was still just out. The code has grown and I haven't had time to make it look like it was written instantaneously. As a result, there are some weird things in here...

* I wrote my own BigInteger class even though .NET 4.0 has a BigInteger class now. I decided to keep the one I had.
* The "digits" of the BigInteger class are 32-bit unsigned ints. There is support for using 64-bit unsigned ints, but the use of 64-bit digits would likely slow down the BigInteger implementation. I left the support in place because there are certain types of 64-bit arithmetic that are likely faster than using whole BigIntegers. For example there is a function to divide a 128-bit number by a 64-bit number, yielding a 64-bit quotient and a 64-bit remainder. I might find a use for it someday, or somebody else might.
* Another reason I left this code in place is because I wrote (but did not publish) a 64-bit Forth implementation in 2003, and it had arithmetic features like this.
* ExprObjModel.CodeGeneration.CodeGenerator is a wrapper around ILGenerator that was written before extension methods existed. Later I wrote the Pascalesque.ExtMethods class which replaces CodeGenerator, but I kept the old one because lots of code (especially ExprObjModel.ProxyGenerator) still uses it.
* SyntaxAnalyzer.cs and PatternMatch.cs were written before MatchSyntax.cs, which was written before [InternalPatternBind](InternalPatternBind).cs and PascalesqueSyntax.cs. It would be interesting to make InternalPatternBind powerful enough to handle real Scheme syntaxes.
* The crypto code doesn't really contain any crypto algorithms; it merely calls the algorithms already in .NET. If your Windows doesn't have the right crypto library, then these functions won't work. Therefore I contend that I am not exporting any cryptography.
* Also, the crypto code may have some flaws anyway.
* There is a bug in the Controlled Window class. It seems that the internal form is receiving a "lost focus" event after it is closed. This causes a "lost focus" message to be posted to the outbound async queue, which throws an exception because it was closed when the "closed" event was handled. (This has since been fixed. I think.)